package tea // import "charm.land/bubbletea/v2"

Package tea provides a framework for building rich terminal user interfaces
based on the paradigms of The Elm Architecture. It's well-suited for simple and
complex terminal applications, either inline, full-window, or a mix of both.
It's been battle-tested in several large projects and is production-ready.

A tutorial is available at
https://github.com/charmbracelet/bubbletea/tree/master/tutorials

Example programs can be found at
https://github.com/charmbracelet/bubbletea/tree/master/examples

CONSTANTS

const (
	KeyUp     = uv.KeyUp
	KeyDown   = uv.KeyDown
	KeyRight  = uv.KeyRight
	KeyLeft   = uv.KeyLeft
	KeyBegin  = uv.KeyBegin
	KeyFind   = uv.KeyFind
	KeyInsert = uv.KeyInsert
	KeyDelete = uv.KeyDelete
	KeySelect = uv.KeySelect
	KeyPgUp   = uv.KeyPgUp
	KeyPgDown = uv.KeyPgDown
	KeyHome   = uv.KeyHome
	KeyEnd    = uv.KeyEnd

	KeyKpEnter    = uv.KeyKpEnter
	KeyKpEqual    = uv.KeyKpEqual
	KeyKpMultiply = uv.KeyKpMultiply
	KeyKpPlus     = uv.KeyKpPlus
	KeyKpComma    = uv.KeyKpComma
	KeyKpMinus    = uv.KeyKpMinus
	KeyKpDecimal  = uv.KeyKpDecimal
	KeyKpDivide   = uv.KeyKpDivide
	KeyKp0        = uv.KeyKp0
	KeyKp1        = uv.KeyKp1
	KeyKp2        = uv.KeyKp2
	KeyKp3        = uv.KeyKp3
	KeyKp4        = uv.KeyKp4
	KeyKp5        = uv.KeyKp5
	KeyKp6        = uv.KeyKp6
	KeyKp7        = uv.KeyKp7
	KeyKp8        = uv.KeyKp8
	KeyKp9        = uv.KeyKp9

	// The following are keys defined in the Kitty keyboard protocol.
	// XXX: Investigate the names of these keys.
	KeyKpSep    = uv.KeyKpSep
	KeyKpUp     = uv.KeyKpUp
	KeyKpDown   = uv.KeyKpDown
	KeyKpLeft   = uv.KeyKpLeft
	KeyKpRight  = uv.KeyKpRight
	KeyKpPgUp   = uv.KeyKpPgUp
	KeyKpPgDown = uv.KeyKpPgDown
	KeyKpHome   = uv.KeyKpHome
	KeyKpEnd    = uv.KeyKpEnd
	KeyKpInsert = uv.KeyKpInsert
	KeyKpDelete = uv.KeyKpDelete
	KeyKpBegin  = uv.KeyKpBegin

	KeyF1  = uv.KeyF1
	KeyF2  = uv.KeyF2
	KeyF3  = uv.KeyF3
	KeyF4  = uv.KeyF4
	KeyF5  = uv.KeyF5
	KeyF6  = uv.KeyF6
	KeyF7  = uv.KeyF7
	KeyF8  = uv.KeyF8
	KeyF9  = uv.KeyF9
	KeyF10 = uv.KeyF10
	KeyF11 = uv.KeyF11
	KeyF12 = uv.KeyF12
	KeyF13 = uv.KeyF13
	KeyF14 = uv.KeyF14
	KeyF15 = uv.KeyF15
	KeyF16 = uv.KeyF16
	KeyF17 = uv.KeyF17
	KeyF18 = uv.KeyF18
	KeyF19 = uv.KeyF19
	KeyF20 = uv.KeyF20
	KeyF21 = uv.KeyF21
	KeyF22 = uv.KeyF22
	KeyF23 = uv.KeyF23
	KeyF24 = uv.KeyF24
	KeyF25 = uv.KeyF25
	KeyF26 = uv.KeyF26
	KeyF27 = uv.KeyF27
	KeyF28 = uv.KeyF28
	KeyF29 = uv.KeyF29
	KeyF30 = uv.KeyF30
	KeyF31 = uv.KeyF31
	KeyF32 = uv.KeyF32
	KeyF33 = uv.KeyF33
	KeyF34 = uv.KeyF34
	KeyF35 = uv.KeyF35
	KeyF36 = uv.KeyF36
	KeyF37 = uv.KeyF37
	KeyF38 = uv.KeyF38
	KeyF39 = uv.KeyF39
	KeyF40 = uv.KeyF40
	KeyF41 = uv.KeyF41
	KeyF42 = uv.KeyF42
	KeyF43 = uv.KeyF43
	KeyF44 = uv.KeyF44
	KeyF45 = uv.KeyF45
	KeyF46 = uv.KeyF46
	KeyF47 = uv.KeyF47
	KeyF48 = uv.KeyF48
	KeyF49 = uv.KeyF49
	KeyF50 = uv.KeyF50
	KeyF51 = uv.KeyF51
	KeyF52 = uv.KeyF52
	KeyF53 = uv.KeyF53
	KeyF54 = uv.KeyF54
	KeyF55 = uv.KeyF55
	KeyF56 = uv.KeyF56
	KeyF57 = uv.KeyF57
	KeyF58 = uv.KeyF58
	KeyF59 = uv.KeyF59
	KeyF60 = uv.KeyF60
	KeyF61 = uv.KeyF61
	KeyF62 = uv.KeyF62
	KeyF63 = uv.KeyF63

	KeyCapsLock    = uv.KeyCapsLock
	KeyScrollLock  = uv.KeyScrollLock
	KeyNumLock     = uv.KeyNumLock
	KeyPrintScreen = uv.KeyPrintScreen
	KeyPause       = uv.KeyPause
	KeyMenu        = uv.KeyMenu

	KeyMediaPlay        = uv.KeyMediaPlay
	KeyMediaPause       = uv.KeyMediaPause
	KeyMediaPlayPause   = uv.KeyMediaPlayPause
	KeyMediaReverse     = uv.KeyMediaReverse
	KeyMediaStop        = uv.KeyMediaStop
	KeyMediaFastForward = uv.KeyMediaFastForward
	KeyMediaRewind      = uv.KeyMediaRewind
	KeyMediaNext        = uv.KeyMediaNext
	KeyMediaPrev        = uv.KeyMediaPrev
	KeyMediaRecord

	KeyLowerVol = uv.KeyLowerVol
	KeyRaiseVol = uv.KeyRaiseVol
	KeyMute     = uv.KeyMute

	KeyLeftShift      = uv.KeyLeftShift
	KeyLeftAlt        = uv.KeyLeftAlt
	KeyLeftCtrl       = uv.KeyLeftCtrl
	KeyLeftSuper      = uv.KeyLeftSuper
	KeyLeftHyper      = uv.KeyLeftHyper
	KeyLeftMeta       = uv.KeyLeftMeta
	KeyRightShift     = uv.KeyRightShift
	KeyRightAlt       = uv.KeyRightAlt
	KeyRightCtrl      = uv.KeyRightCtrl
	KeyRightSuper     = uv.KeyRightSuper
	KeyRightHyper     = uv.KeyRightHyper
	KeyRightMeta      = uv.KeyRightMeta
	KeyIsoLevel3Shift = uv.KeyIsoLevel3Shift
	KeyIsoLevel5Shift = uv.KeyIsoLevel5Shift

	KeyBackspace = uv.KeyBackspace
	KeyTab       = uv.KeyTab
	KeyEnter     = uv.KeyEnter
	KeyReturn    = uv.KeyReturn
	KeyEscape    = uv.KeyEscape
	KeyEsc       = uv.KeyEsc

	KeySpace = uv.KeySpace
)
    Special key symbols.

const (
	ModShift = uv.ModShift
	ModAlt   = uv.ModAlt
	ModCtrl  = uv.ModCtrl
	ModMeta  = uv.ModMeta

	ModHyper = uv.ModHyper
	ModSuper = uv.ModSuper // Windows/Command keys

	ModCapsLock   = uv.ModCapsLock
	ModNumLock    = uv.ModNumLock
	ModScrollLock = uv.ModScrollLock // Defined in Windows API only
)
    Modifier keys.

const (
	MouseNone       = uv.MouseNone
	MouseLeft       = uv.MouseLeft
	MouseMiddle     = uv.MouseMiddle
	MouseRight      = uv.MouseRight
	MouseWheelUp    = uv.MouseWheelUp
	MouseWheelDown  = uv.MouseWheelDown
	MouseWheelLeft  = uv.MouseWheelLeft
	MouseWheelRight = uv.MouseWheelRight
	MouseBackward   = uv.MouseBackward
	MouseForward    = uv.MouseForward
	MouseButton10   = uv.MouseButton10
	MouseButton11
)
    Mouse event buttons

    This is based on X11 mouse button codes.

        1 = left button
        2 = middle button (pressing the scroll wheel)
        3 = right button
        4 = turn scroll wheel up
        5 = turn scroll wheel down
        6 = push scroll wheel left
        7 = push scroll wheel right
        8 = 4th button (aka browser backward button)
        9 = 5th button (aka browser forward button)
        10
        11

    Other buttons are not supported.

const (
	// KeyExtended is a special key code used to signify that a key event
	// contains multiple runes.
	KeyExtended = uv.KeyExtended
)

VARIABLES

var ErrInterrupted = errors.New("program was interrupted")
    ErrInterrupted is returned by Program.Run when the program get a SIGINT
    signal, or when it receives a InterruptMsg.

var ErrProgramKilled = errors.New("program was killed")
    ErrProgramKilled is returned by Program.Run when the program gets killed.

var ErrProgramPanic = errors.New("program experienced a panic")
    ErrProgramPanic is returned by Program.Run when the program recovers from a
    panic.


FUNCTIONS

func LogToFile(path string, prefix string) (*os.File, error)
    LogToFile sets up default logging to log to a file. This is helpful as
    we can't print to the terminal since our TUI is occupying it. If the file
    doesn't exist it will be created.

    Don't forget to close the file when you're done with it.

          f, err := LogToFile("debug.log", "debug")
          if err != nil {
        		fmt.Println("fatal:", err)
        		os.Exit(1)
          }
          defer f.Close()

func LogToFileWith(path string, prefix string, log LogOptionsSetter) (*os.File, error)
    LogToFileWith does allows to call LogToFile with a custom LogOptionsSetter.

func OpenTTY() (*os.File, *os.File, error)
    OpenTTY opens the running terminal's TTY for reading and writing.


TYPES

type BackgroundColorMsg struct{ color.Color }
    BackgroundColorMsg represents a background color message. This message is
    emitted when the program requests the terminal background color with the
    RequestBackgroundColor Cmd.

    This is commonly used in [Update.Init] to get the terminal
    background color for style definitions. For that you'll want to call
    BackgroundColorMsg.IsDark to determine if the color is dark or light.
    For example:

        func (m Model) Init() (Model, Cmd) {
          return m, RequestBackgroundColor()
        }

        func (m Model) Update(msg Msg) (Model, Cmd) {
          switch msg := msg.(type) {
          case BackgroundColorMsg:
              m.styles = newStyles(msg.IsDark())
          }
        }

func (e BackgroundColorMsg) IsDark() bool
    IsDark returns whether the color is dark.

func (e BackgroundColorMsg) String() string
    String returns the hex representation of the color.

type BatchMsg []Cmd
    BatchMsg is a message used to perform a bunch of commands concurrently with
    no ordering guarantees. You can send a BatchMsg with Batch.

type BlurMsg struct{}
    BlurMsg represents a terminal blur message. This occurs when the terminal
    loses focus.

type CapabilityMsg struct {
	Content string
}
    CapabilityMsg represents a Termcap/Terminfo response event. Termcap
    responses are generated by the terminal in response to RequestTermcap
    (XTGETTCAP) requests.

    See:
    https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Operating-System-Commands

func (c CapabilityMsg) String() string
    String returns the capability content as a string.

type ClipboardMsg struct {
	Content   string
	Selection byte
}
    ClipboardMsg is a clipboard read message event. This message is emitted when
    a terminal receives an OSC52 clipboard read message event.

func (e ClipboardMsg) Clipboard() byte
    Clipboard returns the clipboard selection type. This will be one of the
    following values:

      - c: System clipboard.
      - p: Primary clipboard (X11/Wayland only).

func (e ClipboardMsg) String() string
    String returns the string representation of the clipboard message.

type Cmd func() Msg
    Cmd is an IO operation that returns a message when it's complete. If it's
    nil it's considered a no-op. Use it for things like HTTP requests, timers,
    saving and loading from disk, and so on.

    Note that there's almost never a reason to use a command to send a message
    to another part of your program. That can almost always be done in the
    update function.

func Batch(cmds ...Cmd) Cmd
    Batch performs a bunch of commands concurrently with no ordering guarantees
    about the results. Use a Batch to return several commands.

    Example:

            func (m model) Init() (Model, Cmd) {
        	       return m, tea.Batch(someCommand, someOtherCommand)
            }

func Every(duration time.Duration, fn func(time.Time) Msg) Cmd
    Every is a command that ticks in sync with the system clock. So, if you
    wanted to tick with the system clock every second, minute or hour you could
    use this. It's also handy for having different things tick in sync.

    Because we're ticking with the system clock the tick will likely not run for
    the entire specified duration. For example, if we're ticking for one minute
    and the clock is at 12:34:20 then the next tick will happen at 12:35:00,
    40 seconds later.

    To produce the command, pass a duration and a function which returns a
    message containing the time at which the tick occurred.

        type TickMsg time.Time

        cmd := Every(time.Second, func(t time.Time) Msg {
           return TickMsg(t)
        })

    Beginners' note: Every sends a single message and won't automatically
    dispatch messages at an interval. To do that, you'll want to return another
    Every command after receiving your tick message. For example:

        type TickMsg time.Time

        // Send a message every second.
        func tickEvery() Cmd {
            return Every(time.Second, func(t time.Time) Msg {
                return TickMsg(t)
            })
        }

        func (m model) Init() (Model, Cmd) {
            // Start ticking.
            return m, tickEvery()
        }

        func (m model) Update(msg Msg) (Model, Cmd) {
            switch msg.(type) {
            case TickMsg:
                // Return your Every command again to loop.
                return m, tickEvery()
            }
            return m, nil
        }

    Every is analogous to Tick in the Elm Architecture.

func Exec(c ExecCommand, fn ExecCallback) Cmd
    Exec is used to perform arbitrary I/O in a blocking fashion, effectively
    pausing the Program while execution is running and resuming it when
    execution has completed.

    Most of the time you'll want to use ExecProcess, which runs an exec.Cmd.

    For non-interactive i/o you should use a Cmd (that is, a tea.Cmd).

func ExecProcess(c *exec.Cmd, fn ExecCallback) Cmd
    ExecProcess runs the given *exec.Cmd in a blocking fashion, effectively
    pausing the Program while the command is running. After the *exec.Cmd exists
    the Program resumes. It's useful for spawning other interactive applications
    such as editors and shells from within a Program.

    To produce the command, pass an *exec.Cmd and a function which returns
    a message containing the error which may have occurred when running the
    ExecCommand.

        type VimFinishedMsg struct { err error }

        c := exec.Command("vim", "file.txt")

        cmd := ExecProcess(c, func(err error) Msg {
            return VimFinishedMsg{err: err}
        })

    Or, if you don't care about errors, you could simply:

        cmd := ExecProcess(exec.Command("vim", "file.txt"), nil)

    For non-interactive i/o you should use a Cmd (that is, a tea.Cmd).

func Printf(template string, args ...any) Cmd
    Printf prints above the Program. It takes a format template followed by
    values similar to fmt.Printf. This output is unmanaged by the program and
    will persist across renders by the Program.

    Unlike fmt.Printf (but similar to log.Printf) the message will be print on
    its own line.

    If the altscreen is active no output will be printed.

func Println(args ...any) Cmd
    Println prints above the Program. This output is unmanaged by the program
    and will persist across renders by the Program.

    Unlike fmt.Println (but similar to log.Println) the message will be print on
    its own line.

    If the altscreen is active no output will be printed.

func Raw(r any) Cmd
    Raw is a command that prints the given string to the terminal without any
    formatting.

    This is intended for advanced use cases where you need to query the terminal
    or send escape sequences directly. Don't use this unless you know what
    you're doing :)

    Example:

        func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
          switch msg := msg.(type) {
          case input.PrimaryDeviceAttributesEvent:
            for _, attr := range msg {
              if attr == 4 {
                // We have Sixel graphics support!
                break
              }
            }
          }

          // Request the terminal primary device attributes to detect Sixel graphics
          // support.
          return m, tea.Raw(ansi.RequestPrimaryDeviceAttributes)
        }

func RequestCapability(s string) Cmd
    RequestCapability is a command that requests the terminal to send its
    Termcap/Terminfo response for the given capability.

    Bubble Tea recognizes the following capabilities and will use them to
    upgrade the program's color profile:
      - "RGB" Xterm direct color
      - "Tc" True color support

    Note: that some terminal's like Apple's Terminal.app do not support this and
    will send the wrong response to the terminal breaking the program's output.

    When the Bubble Tea advertises a non-TrueColor profile, you can use this
    command to query the terminal for its color capabilities. Example:

        switch msg := msg.(type) {
        case tea.ColorProfileMsg:
          if msg.Profile != colorprofile.TrueColor {
            return m, tea.Batch(
              tea.RequestCapability("RGB"),
              tea.RequestCapability("Tc"),
            )
          }
        }

func Sequence(cmds ...Cmd) Cmd
    Sequence runs the given commands one at a time, in order. Contrast this with
    Batch, which runs commands concurrently.

func SetClipboard(s string) Cmd
    SetClipboard produces a command that sets the system clipboard using OSC52.
    Note that OSC52 is not supported in all terminals.

func SetPrimaryClipboard(s string) Cmd
    SetPrimaryClipboard produces a command that sets the primary clipboard using
    OSC52. Primary clipboard selection is a feature present in X11 and Wayland
    only. Note that OSC52 is not supported in all terminals.

func Tick(d time.Duration, fn func(time.Time) Msg) Cmd
    Tick produces a command at an interval independent of the system clock
    at the given duration. That is, the timer begins precisely when invoked,
    and runs for its entire duration.

    To produce the command, pass a duration and a function which returns a
    message containing the time at which the tick occurred.

        type TickMsg time.Time

        cmd := Tick(time.Second, func(t time.Time) Msg {
           return TickMsg(t)
        })

    Beginners' note: Tick sends a single message and won't automatically
    dispatch messages at an interval. To do that, you'll want to return another
    Tick command after receiving your tick message. For example:

        type TickMsg time.Time

        func doTick() Cmd {
            return Tick(time.Second, func(t time.Time) Msg {
                return TickMsg(t)
            })
        }

        func (m model) Init() (Model, Cmd) {
            // Start ticking.
            return m, doTick()
        }

        func (m model) Update(msg Msg) (Model, Cmd) {
            switch msg.(type) {
            case TickMsg:
                // Return your Tick command again to loop.
                return m, doTick()
            }
            return m, nil
        }

type ColorProfileMsg struct {
	colorprofile.Profile
}
    ColorProfileMsg is a message that describes the terminal's color profile.
    This message is send to the program's update function when the program is
    started.

    To upgrade the terminal color profile, use the `tea.RequestCapability`
    command to request the `RGB` and `Tc` terminfo capabilities. Bubble Tea will
    then cache the terminal's color profile and send a `ColorProfileMsg` to the
    program's update function.

type Cursor struct {
	// Position is a [Position] that determines the cursor's position on the
	// screen relative to the top left corner of the frame.
	Position

	// Color is a [color.Color] that determines the cursor's color.
	Color color.Color

	// Shape is a [CursorShape] that determines the cursor's shape.
	Shape CursorShape

	// Blink is a boolean that determines whether the cursor should blink.
	Blink bool
}
    Cursor represents a cursor on the terminal screen.

func NewCursor(x, y int) *Cursor
    NewCursor returns a new cursor with the default settings and the given
    position.

type CursorColorMsg struct{ color.Color }
    CursorColorMsg represents a cursor color change message. This message is
    emitted when the program requests the terminal cursor color.

func (e CursorColorMsg) IsDark() bool
    IsDark returns whether the color is dark.

func (e CursorColorMsg) String() string
    String returns the hex representation of the color.

type CursorPositionMsg struct {
	X, Y int
}
    CursorPositionMsg is a message that represents the terminal cursor position.

type CursorShape int
    CursorShape represents a terminal cursor shape.

const (
	CursorBlock CursorShape = iota
	CursorUnderline
	CursorBar
)
    Cursor shapes.

type EnvMsg uv.Environ
    EnvMsg is a message that represents the environment variables of the
    program. This is useful for getting the environment variables of programs
    running in a remote session like SSH. In that case, using os.Getenv would
    return the server's environment variables, not the client's.

    This message is sent to the program when it starts.

    Example:

        switch msg := msg.(type) {
        case EnvMsg:
          // What terminal type is being used?
          term := msg.Getenv("TERM")
        }

func (msg EnvMsg) Getenv(key string) (v string)
    Getenv returns the value of the environment variable named by the key.
    If the variable is not present in the environment, the value returned will
    be the empty string.

func (msg EnvMsg) LookupEnv(key string) (s string, v bool)
    LookupEnv retrieves the value of the environment variable named by the key.
    If the variable is present in the environment the value (which may be empty)
    is returned and the boolean is true. Otherwise the returned value will be
    empty and the boolean will be false.

type ExecCallback func(error) Msg
    ExecCallback is used when executing an *exec.Command to return a message
    with an error, which may or may not be nil.

type ExecCommand interface {
	Run() error
	SetStdin(io.Reader)
	SetStdout(io.Writer)
	SetStderr(io.Writer)
}
    ExecCommand can be implemented to execute things in a blocking fashion in
    the current terminal.

type FocusMsg struct{}
    FocusMsg represents a terminal focus message. This occurs when the terminal
    gains focus.

type ForegroundColorMsg struct{ color.Color }
    ForegroundColorMsg represents a foreground color message. This message is
    emitted when the program requests the terminal foreground color with the
    RequestForegroundColor Cmd.

func (e ForegroundColorMsg) IsDark() bool
    IsDark returns whether the color is dark.

func (e ForegroundColorMsg) String() string
    String returns the hex representation of the color.

type InterruptMsg struct{}
    InterruptMsg signals the program should suspend. This usually happens when
    ctrl+c is pressed on common programs, but since bubbletea puts the terminal
    in raw mode, we need to handle it in a per-program basis.

    You can send this message with [Interrupt()].

type Key struct {
	// Text contains the actual characters received. This usually the same as
	// [Key.Code]. When [Key.Text] is non-empty, it indicates that the key
	// pressed represents printable character(s).
	Text string

	// Mod represents modifier keys, like [ModCtrl], [ModAlt], and so on.
	Mod KeyMod

	// Code represents the key pressed. This is usually a special key like
	// [KeyTab], [KeyEnter], [KeyF1], or a printable character like 'a'.
	Code rune

	// ShiftedCode is the actual, shifted key pressed by the user. For example,
	// if the user presses shift+a, or caps lock is on, [Key.ShiftedCode] will
	// be 'A' and [Key.Code] will be 'a'.
	//
	// In the case of non-latin keyboards, like Arabic, [Key.ShiftedCode] is the
	// unshifted key on the keyboard.
	//
	// This is only available with the Kitty Keyboard Protocol or the Windows
	// Console API.
	ShiftedCode rune

	// BaseCode is the key pressed according to the standard PC-101 key layout.
	// On international keyboards, this is the key that would be pressed if the
	// keyboard was set to US PC-101 layout.
	//
	// For example, if the user presses 'q' on a French AZERTY keyboard,
	// [Key.BaseCode] will be 'q'.
	//
	// This is only available with the Kitty Keyboard Protocol or the Windows
	// Console API.
	BaseCode rune

	// IsRepeat indicates whether the key is being held down and sending events
	// repeatedly.
	//
	// This is only available with the Kitty Keyboard Protocol or the Windows
	// Console API.
	IsRepeat bool
}
    Key represents a Key press or release event. It contains information about
    the Key pressed, like the runes, the type of Key, and the modifiers pressed.
    There are a couple general patterns you could use to check for key presses
    or releases:

        // Switch on the string representation of the key (shorter)
        switch msg := msg.(type) {
        case KeyPressMsg:
            switch msg.String() {
            case "enter":
                fmt.Println("you pressed enter!")
            case "a":
                fmt.Println("you pressed a!")
            }
        }

        // Switch on the key type (more foolproof)
        switch msg := msg.(type) {
        case KeyMsg:
            // catch both KeyPressMsg and KeyReleaseMsg
            switch key := msg.Key(); key.Code {
            case KeyEnter:
                fmt.Println("you pressed enter!")
            default:
                switch key.Text {
                case "a":
                    fmt.Println("you pressed a!")
                }
            }
        }

    Note that Key.Text will be empty for special keys like KeyEnter, KeyTab,
    and for keys that don't represent printable characters like key combos with
    modifier keys. In other words, Key.Text is populated only for keys that
    represent printable characters shifted or unshifted (like 'a', 'A', '1',
    '!', etc.).

func (k Key) Keystroke() string
    Keystroke returns the keystroke representation of the Key. While less
    type safe than looking at the individual fields, it will usually be more
    convenient and readable to use this method when matching against keys.

    Note that modifier keys are always printed in the following order:
      - ctrl
      - alt
      - shift
      - meta
      - hyper
      - super

    For example, you'll always see "ctrl+shift+alt+a" and never
    "shift+ctrl+alt+a".

func (k Key) String() string
    String implements fmt.Stringer and is quite useful for matching key events.
    It will return the textual representation of the Key if there is one,
    otherwise, it will fallback to Key.Keystroke.

    For example, you'll always get "?" and instead of "shift+/" on a US ANSI
    keyboard.

type KeyMod = uv.KeyMod
    KeyMod represents modifier keys.

type KeyMsg interface {
	fmt.Stringer

	// Key returns the underlying key event.
	Key() Key
}
    KeyMsg represents a key event. This can be either a key press or a key
    release event.

type KeyPressMsg Key
    KeyPressMsg represents a key press message.

func (k KeyPressMsg) Key() Key
    Key returns the underlying key event. This is a syntactic sugar for casting
    the key event to a Key.

func (k KeyPressMsg) Keystroke() string
    Keystroke returns the keystroke representation of the Key. While less
    type safe than looking at the individual fields, it will usually be more
    convenient and readable to use this method when matching against keys.

    Note that modifier keys are always printed in the following order:
      - ctrl
      - alt
      - shift
      - meta
      - hyper
      - super

    For example, you'll always see "ctrl+shift+alt+a" and never
    "shift+ctrl+alt+a".

func (k KeyPressMsg) String() string
    String implements fmt.Stringer and is quite useful for matching key events.
    For details, on what this returns see Key.String.

type KeyReleaseMsg Key
    KeyReleaseMsg represents a key release message.

func (k KeyReleaseMsg) Key() Key
    Key returns the underlying key event. This is a convenience method and
    syntactic sugar to satisfy the KeyMsg interface, and cast the key event to
    Key.

func (k KeyReleaseMsg) Keystroke() string
    Keystroke returns the keystroke representation of the Key. While less
    type safe than looking at the individual fields, it will usually be more
    convenient and readable to use this method when matching against keys.

    Note that modifier keys are always printed in the following order:
      - ctrl
      - alt
      - shift
      - meta
      - hyper
      - super

    For example, you'll always see "ctrl+shift+alt+a" and never
    "shift+ctrl+alt+a".

func (k KeyReleaseMsg) String() string
    String implements fmt.Stringer and is quite useful for matching key events.
    For details, on what this returns see Key.String.

type KeyboardEnhancements struct {
	// ReportEventTypes requests the terminal to report key repeat and release
	// events.
	// If supported, your program will receive [KeyReleaseMsg]s and
	// [KeyPressMsg] with the [Key.IsRepeat] field set indicating that this is
	// a it's part of a key repeat sequence.
	ReportEventTypes bool
}
    KeyboardEnhancements defines different keyboard enhancement features that
    can be requested from the terminal.

    By default, Bubble Tea requests basic key disambiguation features from the
    terminal. If the terminal supports keyboard enhancements, or any of its
    additional features, it will respond with a KeyboardEnhancementsMsg that
    indicates which features are supported.

    Example:

        ```go
        func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
          switch msg := msg.(type) {
          case tea.KeyboardEnhancementsMsg:
            // We have basic key disambiguation support.
            // We can handle "shift+enter", "ctrl+i", etc.
        	m.keyboardEnhancements = msg
        	if msg.ReportEventTypes {
        	  // Even better! We can now handle key repeat and release events.
        	}
          case tea.KeyPressMsg:
            switch msg.String() {
            case "shift+enter":
              // Handle shift+enter
              // This would not be possible without keyboard enhancements.
            case "ctrl+j":
              // Handle ctrl+j
            }
          case tea.KeyReleaseMsg:
            // Whoa! A key was released!
          }

          return m, nil
        }

        func (m model) View() tea.View {
          v := tea.NewView("Press some keys!")
          // Request reporting key repeat and release events.
          v.KeyboardEnhancements.ReportEventTypes = true
          return v
        }
        ```

type KeyboardEnhancementsMsg struct {
	// Flags is a bitmask of enabled keyboard enhancement features. A non-zero
	// value indicates that at least we have key disambiguation support.
	//
	// See [ansi.KittyReportEventTypes] and other constants for details.
	//
	// Example:
	//
	//  ```go
	//  // The hard way
	//  if msg.Flags&ansi.KittyReportEventTypes != 0 {
	//     // Terminal supports reporting different key event types
	//  }
	//
	//  // The easy way
	//  if msg.SupportsEventTypes() {
	//     // Terminal supports reporting different key event types
	//  }
	//  ```
	Flags int
}
    KeyboardEnhancementsMsg is a message that gets sent when the terminal
    supports keyboard enhancements.

func (k KeyboardEnhancementsMsg) SupportsEventTypes() bool
    SupportsEventTypes returns whether the terminal supports reporting different
    types of key events (press, release, and repeat).

func (k KeyboardEnhancementsMsg) SupportsKeyDisambiguation() bool
    SupportsKeyDisambiguation returns whether the terminal supports key
    disambiguation (e.g., distinguishing between different modifier keys).

type LogOptionsSetter interface {
	SetOutput(io.Writer)
	SetPrefix(string)
}
    LogOptionsSetter is an interface implemented by stdlib's log and charm's log
    libraries.

type ModeReportMsg struct {
	// Mode is the mode number.
	Mode ansi.Mode

	// Value is the mode value.
	Value ansi.ModeSetting
}
    ModeReportMsg is a message that represents a mode report event (DECRPM).

    This is sent by the terminal in response to a request for a terminal mode
    report (DECRQM). It indicates the current setting of a specific terminal
    mode like cursor visibility, mouse tracking, etc.

    Example:

        ```go
        func (m model) Init() tea.Cmd {
          // Does my terminal support reporting focus events?
          return tea.Raw(ansi.RequestModeFocusEvent)
        }

        func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
          switch msg := msg.(type) {
          case tea.ModeReportMsg:
            if msg.Mode == ansi.ModeFocusEvent && !msg.Value.IsNotRecognized() {
              // Terminal supports focus events
              m.supportsFocus = true
            }
          }
          return m, nil
        }

        func (m model) View() tea.View {
          var view tea.View
          view.ReportFocus = m.supportsFocus
          view.SetContent(fmt.Sprintf("Terminal supports focus events: %v", m.supportsFocus))
          return view
        }
        ```

    See: https://vt100.net/docs/vt510-rm/DECRPM.html

type Model interface {
	// Init is the first function that will be called. It returns an optional
	// initial command. To not perform an initial command return nil.
	Init() Cmd

	// Update is called when a message is received. Use it to inspect messages
	// and, in response, update the model and/or send a command.
	Update(Msg) (Model, Cmd)

	// View renders the program's UI, which can be a string or a [Layer]. The
	// view is rendered after every Update.
	View() View
}
    Model contains the program's state as well as its core functions.

type Mouse struct {
	X, Y   int
	Button MouseButton
	Mod    KeyMod
}
    Mouse represents a Mouse message. Use MouseMsg to represent all mouse
    messages.

    The X and Y coordinates are zero-based, with (0,0) being the upper left
    corner of the terminal.

        // Catch all mouse events
        switch msg := msg.(type) {
        case MouseMsg:
            m := msg.Mouse()
            fmt.Println("Mouse event:", m.X, m.Y, m)
        }

        // Only catch mouse click events
        switch msg := msg.(type) {
        case MouseClickMsg:
            fmt.Println("Mouse click event:", msg.X, msg.Y, msg)
        }

func (m Mouse) String() (s string)
    String returns a string representation of the mouse message.

type MouseButton = uv.MouseButton
    MouseButton represents the button that was pressed during a mouse message.

type MouseClickMsg Mouse
    MouseClickMsg represents a mouse button click message.

func (e MouseClickMsg) Mouse() Mouse
    Mouse returns the underlying mouse event. This is a convenience method and
    syntactic sugar to satisfy the MouseMsg interface, and cast the mouse event
    to Mouse.

func (e MouseClickMsg) String() string
    String returns a string representation of the mouse click message.

type MouseMode int
    MouseMode represents the mouse mode of a view.

const (
	// MouseModeNone disables mouse events.
	MouseModeNone MouseMode = iota

	// MouseModeCellMotion enables mouse click, release, and wheel events.
	// Mouse movement events are also captured if a mouse button is pressed
	// (i.e., drag events). Cell motion mode is better supported than all
	// motion mode.
	//
	// This will try to enable the mouse in extended mode (SGR), if that is not
	// supported by the terminal it will fall back to normal mode (X10).
	MouseModeCellMotion

	// MouseModeAllMotion enables all mouse events, including click, release,
	// wheel, and movement events. You will receive mouse movement events even
	// when no buttons are pressed.
	//
	// This will try to enable the mouse in extended mode (SGR), if that is not
	// supported by the terminal it will fall back to normal mode (X10).
	MouseModeAllMotion
)
type MouseMotionMsg Mouse
    MouseMotionMsg represents a mouse motion message.

func (e MouseMotionMsg) Mouse() Mouse
    Mouse returns the underlying mouse event. This is a convenience method and
    syntactic sugar to satisfy the MouseMsg interface, and cast the mouse event
    to Mouse.

func (e MouseMotionMsg) String() string
    String returns a string representation of the mouse motion message.

type MouseMsg interface {
	fmt.Stringer

	// Mouse returns the underlying mouse event.
	Mouse() Mouse
}
    MouseMsg represents a mouse message. This is a generic mouse message that
    can represent any kind of mouse event.

type MouseReleaseMsg Mouse
    MouseReleaseMsg represents a mouse button release message.

func (e MouseReleaseMsg) Mouse() Mouse
    Mouse returns the underlying mouse event. This is a convenience method and
    syntactic sugar to satisfy the MouseMsg interface, and cast the mouse event
    to Mouse.

func (e MouseReleaseMsg) String() string
    String returns a string representation of the mouse release message.

type MouseWheelMsg Mouse
    MouseWheelMsg represents a mouse wheel message event.

func (e MouseWheelMsg) Mouse() Mouse
    Mouse returns the underlying mouse event. This is a convenience method and
    syntactic sugar to satisfy the MouseMsg interface, and cast the mouse event
    to Mouse.

func (e MouseWheelMsg) String() string
    String returns a string representation of the mouse wheel message.

type Msg = uv.Event
    Msg contain data from the result of a IO operation. Msgs trigger the update
    function and, henceforth, the UI.

func ClearScreen() Msg
    ClearScreen is a special command that tells the program to clear the screen
    before the next update. This can be used to move the cursor to the top left
    of the screen and clear visual clutter when the alt screen is not in use.

    Note that it should never be necessary to call ClearScreen() for regular
    redraws.

func Interrupt() Msg
    Interrupt is a special command that tells the Bubble Tea program to
    interrupt.

func Quit() Msg
    Quit is a special command that tells the Bubble Tea program to exit.

func ReadClipboard() Msg
    ReadClipboard produces a command that reads the system clipboard using
    OSC52. Note that OSC52 is not supported in all terminals.

func ReadPrimaryClipboard() Msg
    ReadPrimaryClipboard produces a command that reads the primary clipboard
    using OSC52. Primary clipboard selection is a feature present in X11 and
    Wayland only. Note that OSC52 is not supported in all terminals.

func RequestBackgroundColor() Msg
    RequestBackgroundColor is a command that requests the terminal background
    color.

func RequestCursorColor() Msg
    RequestCursorColor is a command that requests the terminal cursor color.

func RequestCursorPosition() Msg
    RequestCursorPosition is a command that requests the cursor position.
    The cursor position will be sent as a CursorPositionMsg message.

func RequestForegroundColor() Msg
    RequestForegroundColor is a command that requests the terminal foreground
    color.

func RequestTerminalVersion() Msg
    RequestTerminalVersion is a command that queries the terminal for its
    version using XTVERSION. Note that some terminals may not support this
    command.

func RequestWindowSize() Msg
    RequestWindowSize is a command that queries the terminal for its current
    size. It delivers the results to Update via a WindowSizeMsg. Keep in mind
    that WindowSizeMsgs will automatically be delivered to Update when the
    Program starts and when the window dimensions change so in many cases you
    will not need to explicitly invoke this command.

func Suspend() Msg
    Suspend is a special command that tells the Bubble Tea program to suspend.

type PasteEndMsg struct{}
    PasteEndMsg is an message that is emitted when the terminal ends the
    bracketed-paste text.

type PasteMsg struct {
	Content string
}
    PasteMsg is an message that is emitted when a terminal receives pasted text
    using bracketed-paste.

func (p PasteMsg) String() string
    String returns the pasted content as a string.

type PasteStartMsg struct{}
    PasteStartMsg is an message that is emitted when the terminal starts the
    bracketed-paste text.

type Position struct{ X, Y int }
    Position represents a position in the terminal.

type Program struct {
	// Has unexported fields.
}
    Program is a terminal user interface.

func NewProgram(model Model, opts ...ProgramOption) *Program
    NewProgram creates a new Program.

func (p *Program) Kill()
    Kill stops the program immediately and restores the former terminal state.
    The final render that you would normally see when quitting will be skipped.
    [program.Run] returns a ErrProgramKilled error.

func (p *Program) Printf(template string, args ...any)
    Printf prints above the Program. It takes a format template followed by
    values similar to fmt.Printf. This output is unmanaged by the program and
    will persist across renders by the Program.

    Unlike fmt.Printf (but similar to log.Printf) the message will be print on
    its own line.

    If the altscreen is active no output will be printed.

func (p *Program) Println(args ...any)
    Println prints above the Program. This output is unmanaged by the program
    and will persist across renders by the Program.

    If the altscreen is active no output will be printed.

func (p *Program) Quit()
    Quit is a convenience function for quitting Bubble Tea programs. Use it when
    you need to shut down a Bubble Tea program from the outside.

    If you wish to quit from within a Bubble Tea program use the Quit command.

    If the program is not running this will be a no-op, so it's safe to call if
    the program is unstarted or has already exited.

func (p *Program) ReleaseTerminal() error
    ReleaseTerminal restores the original terminal state and cancels the input
    reader. You can return control to the Program with RestoreTerminal.

func (p *Program) RestoreTerminal() error
    RestoreTerminal reinitializes the Program's input reader, restores the
    terminal to the former state when the program was running, and repaints.
    Use it to reinitialize a Program after running ReleaseTerminal.

func (p *Program) Run() (returnModel Model, returnErr error)
    Run initializes the program and runs its event loops, blocking until it gets
    terminated by either Program.Quit, Program.Kill, or its signal handler.
    Returns the final model.

func (p *Program) Send(msg Msg)
    Send sends a message to the main update function, effectively allowing
    messages to be injected from outside the program for interoperability
    purposes.

    If the program hasn't started yet this will be a blocking operation. If the
    program has already been terminated this will be a no-op, so it's safe to
    send messages after the program has exited.

func (p *Program) Wait()
    Wait waits/blocks until the underlying Program finished shutting down.

type ProgramOption func(*Program)
    ProgramOption is used to set options when initializing a Program. Program
    can accept a variable number of options.

    Example usage:

        p := NewProgram(model, WithInput(someInput), WithOutput(someOutput))

func WithColorProfile(profile colorprofile.Profile) ProgramOption
    WithColorProfile sets the color profile that the program will use.
    This is useful when you want to force a specific color profile. By default,
    Bubble Tea will try to detect the terminal's color profile from environment
    variables and terminfo capabilities. Use tea.WithEnvironment to set custom
    environment variables.

func WithContext(ctx context.Context) ProgramOption
    WithContext lets you specify a context in which to run the Program. This is
    useful if you want to cancel the execution from outside. When a Program gets
    cancelled it will exit with an error ErrProgramKilled.

func WithEnvironment(env []string) ProgramOption
    WithEnvironment sets the environment variables that the program will use.
    This useful when the program is running in a remote session (e.g. SSH) and
    you want to pass the environment variables from the remote session to the
    program.

    Example:

        var sess ssh.Session // ssh.Session is a type from the github.com/charmbracelet/ssh package
        pty, _, _ := sess.Pty()
        environ := append(sess.Environ(), "TERM="+pty.Term)
        p := tea.NewProgram(model, tea.WithEnvironment(environ)

func WithFPS(fps int) ProgramOption
    WithFPS sets a custom maximum FPS at which the renderer should run. If less
    than 1, the default value of 60 will be used. If over 120, the FPS will be
    capped at 120.

func WithFilter(filter func(Model, Msg) Msg) ProgramOption
    WithFilter supplies an event filter that will be invoked before Bubble Tea
    processes a tea.Msg. The event filter can return any tea.Msg which will then
    get handled by Bubble Tea instead of the original event. If the event filter
    returns nil, the event will be ignored and Bubble Tea will not process it.

    As an example, this could be used to prevent a program from shutting down if
    there are unsaved changes.

    Example:

        func filter(m tea.Model, msg tea.Msg) tea.Msg {
        	if _, ok := msg.(tea.QuitMsg); !ok {
        		return msg
        	}

        	model := m.(myModel)
        	if model.hasChanges {
        		return nil
        	}

        	return msg
        }

        p := tea.NewProgram(Model{}, tea.WithFilter(filter));

        if _,err := p.Run(); err != nil {
        	fmt.Println("Error running program:", err)
        	os.Exit(1)
        }

func WithInput(input io.Reader) ProgramOption
    WithInput sets the input which, by default, is stdin. In most cases you
    won't need to use this. To disable input entirely pass nil.

        p := NewProgram(model, WithInput(nil))

func WithOutput(output io.Writer) ProgramOption
    WithOutput sets the output which, by default, is stdout. In most cases you
    won't need to use this.

func WithWindowSize(width, height int) ProgramOption
    WithWindowSize sets the initial size of the terminal window. This is useful
    when you need to set the initial size of the terminal window, for example
    during testing or when you want to run your program in a non-interactive
    environment.

func WithoutCatchPanics() ProgramOption
    WithoutCatchPanics disables the panic catching that Bubble Tea does by
    default. If panic catching is disabled the terminal will be in a fairly
    unusable state after a panic because Bubble Tea will not perform its usual
    cleanup on exit.

func WithoutRenderer() ProgramOption
    WithoutRenderer disables the renderer. When this is set output and log
    statements will be plainly sent to stdout (or another output if one is set)
    without any rendering and redrawing logic. In other words, printing and
    logging will behave the same way it would in a non-TUI commandline tool.
    This can be useful if you want to use the Bubble Tea framework for a non-TUI
    application, or to provide an additional non-TUI mode to your Bubble Tea
    programs. For example, your program could behave like a daemon if output is
    not a TTY.

func WithoutSignalHandler() ProgramOption
    WithoutSignalHandler disables the signal handler that Bubble Tea sets up for
    Programs. This is useful if you want to handle signals yourself.

func WithoutSignals() ProgramOption
    WithoutSignals will ignore OS signals. This is mainly useful for testing.

type ProgressBar struct {
	// State is the current state of the progress bar. It can be one of
	// [ProgressBarNone], [ProgressBarDefault], [ProgressBarError],
	// [ProgressBarIndeterminate], and [ProgressBarWarn].
	State ProgressBarState
	// Value is the current value of the progress bar. It should be between
	// 0 and 100.
	Value int
}
    ProgressBar represents the terminal progress bar.

    Support depends on the terminal.

    See
    https://learn.microsoft.com/en-us/windows/terminal/tutorials/progress-bar-sequences

func NewProgressBar(state ProgressBarState, value int) *ProgressBar
    NewProgressBar returns a new progress bar with the given state
    and value. The value is ignored if the state is ProgressBarNone or
    ProgressBarIndeterminate.

type ProgressBarState int
    ProgressBarState represents the state of the progress bar.

const (
	ProgressBarNone ProgressBarState = iota
	ProgressBarDefault
	ProgressBarError
	ProgressBarIndeterminate
	ProgressBarWarning
)
    Progress bar states.

func (s ProgressBarState) String() string
    String return a human-readable value for the given ProgressBarState.

type QuitMsg struct{}
    QuitMsg signals that the program should quit. You can send a QuitMsg with
    Quit.

type RawMsg struct {
	Msg any
}
    RawMsg is a message that contains a string to be printed to the terminal
    without any intermediate processing.

type ResumeMsg struct{}
    ResumeMsg can be listen to do something once a program is resumed back from
    a suspend state.

type SuspendMsg struct{}
    SuspendMsg signals the program should suspend. This usually happens when
    ctrl+z is pressed on common programs, but since bubbletea puts the terminal
    in raw mode, we need to handle it in a per-program basis.

    You can send this message with [Suspend()].

type TerminalVersionMsg struct {
	Name string
}
    TerminalVersionMsg is a message that represents the terminal version.

func (t TerminalVersionMsg) String() string
    String returns the terminal name as a string.

type View struct {
	// Content is the screen content of the view. It holds styled strings that
	// will be rendered to the terminal when the view is rendered.
	//
	// A styled string represents text with styles and hyperlinks encoded as
	// ANSI escape codes.
	//
	// Example:
	//
	//  ```go
	//  v := tea.NewView("Hello, World!")
	//  ```
	Content string

	// OnMouse is an optional mouse message handler that can be used to
	// intercept mouse messages that depends on view content from last render.
	// It can be useful for implementing view-specific behavior without
	// breaking the unidirectional data flow of Bubble Tea.
	//
	// Example:
	//
	//  ```go
	//  content := "Hello, World!"
	//  v := tea.NewView(content)
	//  v.OnMouse = func(msg tea.MouseMsg) tea.Cmd {
	//      return func() tea.Msg {
	//        m := msg.Mouse()
	//        // Check if the mouse is within the bounds of "World!"
	//        start := strings.Index(content, "World!")
	//        end := start + len("World!")
	//        if m.Y == 0 && m.X >= start && m.X < end {
	//          // Mouse is over "World!"
	//          return MyCustomMsg{
	//            MouseMsg: msg,
	//          }
	//		  }
	//      }
	//    }
	//    return nil
	//  }
	//  return v
	//  ```
	OnMouse func(msg MouseMsg) Cmd

	// Cursor represents the cursor position, style, and visibility on the
	// screen. When not nil, the cursor will be shown at the specified
	// position.
	Cursor *Cursor

	// BackgroundColor when not nil, sets the terminal background color. Use
	// nil to reset to the terminal's default background color.
	BackgroundColor color.Color

	// ForegroundColor when not nil, sets the terminal foreground color. Use
	// nil to reset to the terminal's default foreground color.
	ForegroundColor color.Color

	// WindowTitle sets the terminal window title. Support depends on the
	// terminal.
	WindowTitle string

	// ProgressBar when not nil, shows a progress bar in the terminal's
	// progress bar section. Support depends on the terminal.
	ProgressBar *ProgressBar

	// AltScreen puts the program in the alternate screen buffer
	// (i.e. the program goes into full window mode). Note that the altscreen will
	// be automatically exited when the program quits.
	//
	// Example:
	//
	//	func (m model) View() tea.View {
	//	    v := tea.NewView("Hello, World!")
	//	    v.AltScreen = true
	//	    return v
	//	}
	//
	AltScreen bool

	// ReportFocus enables reporting when the terminal gains and loses focus.
	// When this is enabled [FocusMsg] and [BlurMsg] messages will be sent to
	// your Update method.
	//
	// Note that while most terminals and multiplexers support focus reporting,
	// some do not. Also note that tmux needs to be configured to report focus
	// events.
	ReportFocus bool

	// DisableBracketedPasteMode disables bracketed paste mode for this view.
	DisableBracketedPasteMode bool

	// MouseMode sets the mouse mode for this view. It can be one of
	// [MouseModeNone], [MouseModeCellMotion], or [MouseModeAllMotion].
	MouseMode MouseMode

	// KeyboardEnhancements describes what keyboard enhancement features Bubble
	// Tea should request from the terminal.
	//
	// Bubble Tea supports requesting the following keyboard enhancement features:
	//   - ReportEventTypes: requests the terminal to report key repeat and
	//     release events.
	//
	// If the terminal supports any of these features, your program will
	// receive  a [KeyboardEnhancementsMsg] that indicates which features are
	// available.
	KeyboardEnhancements KeyboardEnhancements
}
    View represents a terminal view that can be composed of multiple layers.
    It can also contain a cursor that will be rendered on top of the layers.

func NewView(s string) View
    NewView is a helper function to create a new View with the given styled
    string. A styled string represents text with styles and hyperlinks encoded
    as ANSI escape codes.

    Example:

        ```go
        v := tea.NewView("Hello, World!")
        ```

func (v *View) SetContent(s string)
    SetContent is a helper method to set the content of a View with a styled
    string. A styled string represents text with styles and hyperlinks encoded
    as ANSI escape codes.

    Example:

        ```go
        var v tea.View
        v.SetContent("Hello, World!")
        ```

type WindowSizeMsg struct {
	Width  int
	Height int
}
    WindowSizeMsg is used to report the terminal size. It's sent to Update once
    initially and then on every terminal resize. Note that Windows does not have
    support for reporting when resizes occur as it does not support the SIGWINCH
    signal.

